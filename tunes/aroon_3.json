{
 "source": "\"\"\"\n\u2554\u2550\u2557\u2554\u2566\u2557\u2566\u2550\u2557\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u2550\u2557 \u2566\n\u2551\u2550\u256c\u2557\u2551 \u2560\u2566\u255d\u2560\u2550\u2563 \u2551\u2551\u2551\u2563 \u2554\u2569\u2566\u255d\n\u255a\u2550\u255d\u255a\u2569 \u2569\u255a\u2550\u2569 \u2569\u2550\u2569\u255d\u255a\u2550\u255d\u2569 \u255a\u2550\n\nexample.py\n\nIndicators and Strategy for Bot\n\nIndicators:\n1. **Aroon Oscillator**:\n   - The bot uses the Aroon Oscillator (Aroon Osc) to identify the strength of a trend.\n   - The Aroon Oscillator is calculated using the high and low prices over a specified period (`aroon_period`).\n   - The Aroon Oscillator is a momentum indicator that ranges between -100 and +100, where:\n     - Positive values indicate that the asset is in an uptrend.\n     - Negative values indicate that the asset is in a downtrend.\n   - The Aroon Oscillator is used to determine the potential buy or sell points based on whether the oscillator crosses certain threshold values (`buy_thresh` and `sell_thresh`).\n\nStrategy:\n1. **Aroon Oscillator Strategy**:\n   - The bot utilizes the Aroon Oscillator to identify market conditions and make trading decisions based on specific threshold values.\n   \n   - **qx.Buy Signal**: \n     - The bot triggers a buy when the Aroon Oscillator value is below the specified `buy_thresh` \n     (e.g., -50), indicating that the market is in a potential uptrend.\n\n\n   - **qx.Sell Signal**:\n     - The bot triggers a sell when the Aroon Oscillator value is above the specified `sell_thresh` \n     (e.g., +50), indicating that the market is in a potential downtrend.\n\n\nThe example script has a full listing of QPSO Fitness Cost Functions\n\nFitness:\n- The fitness function calculates various performance metrics based on the bot's balance history and trade states:\n  - **ROI (Return on Investment)**: Measures the profitability of the strategy.\n  - **CAGR (Compound Annual Growth Rate)**: The annual growth rate of the investment.\n  - **Sharpe Ratio**: Measures the risk-adjusted return.\n  - **Sortino Ratio**: Similar to the Sharpe ratio, but focuses on downside risk.\n  - **Maximum Drawdown**: The largest drop in account balance from a peak to a trough.\n  - **Calmar Ratio**: The ratio of CAGR to maximum drawdown.\n  - **Omega Ratio**: The ratio of profits to losses.\n  - **Beta**: Measures the volatility of the bot relative to the market.\n  - **Alpha**: The excess return over the market return.\n  - **Information Ratio**: Measures the risk-adjusted performance relative to a benchmark.\n  - **Profit Factor**: The ratio of total profits to total losses.\n  - **Trade Win Rate**: The percentage of profitable trades.\n  - **Payoff Ratio**: The ratio of wins to losses in terms of value.\n  - **Skewness and Kurtosis**: Statistical measures of the distribution of returns.\n  - **Efficiency Ratio**: Measures how efficiently the bot is trading.\n  - **Drawdown Duration**: The length of time it takes to recover from a drawdown.\n  - **Hurst Exponent**: Measures the long-term memory of the\n\n\"\"\"\n\n\nimport math\nimport time\n\nimport numpy as np\nimport qtradex as qx\n\n\nclass Aroon(qx.BaseBot):\n    def __init__(self):\n        self.tune = {\"aroon_period\": 15.0, \"sell_thresh\": 50.0, \"buy_thresh\": 50.0}\n        self.tune = {\n            \"aroon_period\": 18.23944232459082,\n            \"sell_thresh\": 2.512268085738901,\n            \"buy_thresh\": 1.150776158276998,\n        }\n\n        self.clamps = [\n            # min, max, strength\n            [5, 50, 1],\n            [1, 100, 1],\n            [1, 100, 1],\n        ]\n        \n\n    def indicators(self, data):\n        # tulip indicators are exposed via qx.indicators.tulipy\n        # and cached on backend for optimization speed\n        return {\n            \"aroon_osc\": qx.float_period(\n                qx.tu.aroonosc,\n                (data[\"high\"], data[\"low\"], self.tune[\"aroon_period\"]),\n                (2,),\n            ),\n        }\n\n    def plot(self, data, states, indicators, block):\n        qx.plot(\n            data,\n            states,\n            indicators,\n            block,\n            ((\"aroon_osc\", \"Aroon Oscillator\", \"green\", 1, \"Osc\"),),\n        )\n\n    def strategy(self, state, indicators):\n        if state[\"last_trade\"] is None:\n            return qx.Buy()\n        if indicators[\"aroon_osc\"] < -self.tune[\"sell_thresh\"] and isinstance(\n            state[\"last_trade\"], qx.Buy\n        ):\n            return qx.Sell()\n        if indicators[\"aroon_osc\"] > self.tune[\"buy_thresh\"] and isinstance(\n            state[\"last_trade\"], qx.Sell\n        ):\n            return qx.Buy()\n        return None\n\n    def fitness(self, states, raw_states, asset, currency):\n        return [\"roi\", \"sharpe\"], {}\n\n\ndef main():\n    asset, currency = \"BTC\", \"USDT\"\n    wallet = qx.PaperWallet({asset: 0, currency: 1})\n    data = qx.Data(\n        exchange=\"kucoin\",\n        asset=asset,\n        currency=currency,\n        begin=\"2022-01-01\",\n        end=\"2024-01-01\",\n    )\n\n    bot = Aroon()\n    # bot.tune = TUNE\n    try:\n        bot.tune = qx.load_tune(bot, \"BEST ROI TUNE\")\n    except:\n        pass\n    qx.dispatch(bot, data, wallet)\n\n\nif __name__ == \"__main__\":\n    main()\n",
 "BEST ROI TUNE_Wed Mar 26 21:19:30 2025": {
  "tune": {
   "aroon_period": 15.789066933321415,
   "sell_thresh": 2.640278750824835,
   "buy_thresh": 1.1615616086346858
  },
  "results": {
   "roi": 1.055208066889934
  }
 }
}